% -*- LaTeX -*-

\newif\ifoneside
\onesidetrue

\newif\ifuselinks
\uselinkstrue

\IfFileExists{RSA-ifuselinks.tex}{\input{RSA-ifuselinks.tex}}{}

\ifoneside
  \documentclass[pdflatex,11pt,a4paper,oneside]{article}
\else
  \documentclass[pdflatex,11pt,a4paper]{article}
\fi

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\usepackage[italian]{babel}
\usepackage{fancyhdr}
\usepackage{verbatim}
\usepackage{amsfonts,mathrsfs,amsmath,amssymb,amstext,amsthm}
\usepackage{xcolor}

\usepackage[perpage,symbol]{footmisc}

% hyperref should be the last package to be loaded.
\ifuselinks\usepackage{hyperref}\fi

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\newcommand{\theauthor}[0]{Stefano Lattarini}
\newcommand{\thetitle}[0]{Cenni teorici sul crittosistema RSA}

\newcommand{\TFA}{teorema fondamentale dell'aritmetica}

\renewcommand{\phi}{\varphi}

\newcommand{\XXX}[1][XXX]{\text{\bfseries{\color{red}{\emph{#1}}}}}
\newcommand{\TODO}[0]{\XXX[TODO]}
\newcommand{\FIXME}[0]{\XXX[FIXME]}
\newcommand{\UNEXPANDED}[0]{\XXX[SHOULD-BE-UNEXPANDED]}

\newcommand{\acro}[1]{\text{{\frenchspacing {#1} }}}
\newcommand{\ie}[0]{\acro{i.e.}}
\newcommand{\eg}[0]{\acro{e.g.}}
\newcommand{\tc}[0]{\acro{t.c.}}

\newcommand{\p}[1]{\left({#1}\right)}
\newcommand{\q}[1]{\left({#1}\right)^2}
\newcommand{\abs}[1]{\left|{#1}\right|}
\newcommand{\card}[1]{\abs{#1}}
\newcommand{\varcard}[2][\,]{\pmb{\#}{#1}{#2}}

\newcommand{\N}[0]{\mathbb{N}}
\newcommand{\Z}[0]{\mathbb{Z}}

\newcommand{\divides}[0]{\mid}
\newcommand{\notdivides}[0]{\nmid}

\newcommand{\congruent}[0]{\equiv}
\newcommand{\notcongruent}[0]{\not\equiv}
\newcommand{\mmodop}[0]{\ensuremath{\operatorname{mod}}}
\newcommand{\mmod}[1]{\ensuremath{\allowbreak\ (\mmodop\:{#1})}}
\newcommand{\xmod}[1]{\ensuremath{\allowbreak\ \left(\mmodop\:{#1}\right)}}

\newcommand{\cc}[2][m]{\ensuremath{\left[\:{#2}\,\right]_{\,#1}}}

\newcommand{\iseq}[1]{\ensuremath{0,\,1,\,\ldots,\, {#1} - 1}}
\newcommand{\set}[1]{\ensuremath{\left\{\,{#1}\,\right\}}}
\newcommand{\setdef}[2]{\set{{#1}:\:{#2}}}

\newcommand{\gcdop}[0]{\ensuremath{\mathtt{g.c.d.}}}
\newcommand{\xgcd}[1]{\ensuremath{\gcdop\left({#1}\right)}}
\renewcommand{\gcd}[2]{\xgcd{{#1},\,{#2}}}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\newtheorem{TheoremLike}{\UNEXPANDED}
\newtheorem{algorithm}[TheoremLike]{Algoritmo}
\newtheorem{*xalgorithm}{Algoritmo}
\newtheorem{theorem}[TheoremLike]{Teorema}
\newtheorem*{xtheorem}{Teorema}
\newtheorem{definition}[TheoremLike]{Definizione}
\newtheorem*{xdefinition}{Definizione}
\newtheorem{lemma}[TheoremLike]{Lemma}
\newtheorem*{xlemma}{Lemma}
\newtheorem{corollary}[TheoremLike]{Corollario}
\newtheorem*{xcorollary}{Corollario}
\newtheorem{proposition}[TheoremLike]{Proposizione}
\newtheorem*{xproposition}{Proposizione}
\newtheorem{example}[TheoremLike]{Esempio}
\newtheorem*{xexample}{Esempio}
\newtheorem{property}[TheoremLike]{Propriet\`a}
\newtheorem*{xproperty}{Propriet\`a}
\newtheorem{remark}[TheoremLike]{Osservazione}
\newtheorem*{xremark}{Osservazione}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markright{\thesection~\:#1}}
\fancyhf{} % clear all header fields
\fancyhead[RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\ifoneside
  \relax
\else
  \fancyhead[RE]{\bfseries\leftmark}
  \fancyhead[LE]{\bfseries\thepage}
\fi
\fancyfoot{} % clear all footer fields
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{0.5pt}
\fancypagestyle{plain}{
  \fancyhf{} % clear all header and footer fields
  \fancyfoot[C]{\bfseries \thepage} % except the center
  \renewcommand{\headrulewidth}{0pt}
  \renewcommand{\footrulewidth}{0pt}
}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\DefineFNsymbols*{myftnsymbol}{%
  \dagger%
  \ddagger%
  \S%
  \sharp%
  \clubsuit%
  \spadesuit%
  \P%
}

\setfnsymbol{myftnsymbol}

\ifuselinks
  \hypersetup{
    backref,
    pdftitle={\thetitle},
    pdfauthor={\theauthor}
    pdfborder={0 0 0},
    anchorcolor=green,
    colorlinks,
    linkcolor=blue,
    pdfpagelabels
  }
\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title{\thetitle}
\author{\theauthor}
%\date{YEAR-MONTH-DAY}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
  Cenni di teoria circa la nostra implementazione didattica del
  crittosistema RSA.  Si assume una conoscenza di base dell'aritmetica
  teorica -- e.g., principio di induzione e del minimo intero, definizione
  e semplici propriet\`a dei numeri primi e composti, \TFA, divisione con
  resto, eccetera.  Alcuni di questi concetti saranno comunque brevemente
  richiamati.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Nozioni preliminari}

Le nozioni qui riportate dovrebbero essere ben note, quindi le
passeremo in rassegna molto velocemente, solo per avere riferimenti
facilmente accessibile nel seguito.

\begin{theorem}[Teorema di divisione]
Dati due interi (non necessariamente positivi) $a$ e $b$ con $b \neq 0$,
esistono due interi $q$ ed $r$ tali che $a = bq + r$ e $0 \leq r
< \abs{b}$. Essi sono unici, e sono chiamati rispettivamente
\emph{quoziente} e \emph{resto} della divisione di $a$ per $b$.
Il resto si indica, dove conveniente, come \,$r = a\:\mmodop\:b$.
\end{theorem}

\begin{definition}[Numeri primi e composti]
Un intero $p > 1$ che sia divisibile soltanto per s\`e stesso e per
l'unit\`a \`e detto \emph{numero primo}.  Un intero $m > 1$ che non
sia primo \`e detto \emph{composto}; in tal caso esistono due interi
$m_1$, $m_2$ con $1 < m_i < m$ tali che $m = m_1 m_2$.
\end{definition}

\begin{definition}[Interi coprimi]
Due interi si dicono \emph{coprimi} (ovvero \emph{primi tra loro}) se
non hanno divisori comuni al di fuori dell'unit\`a.
\end{definition}

\begin{theorem}[Teorema fondamentale dell'aritmetica]
Ogni intero positivo possiede una fattorizzazione in numeri primi, e
tale fattorizzazione \`e unica (a meno di un riordinamento dei fattori).
\end{theorem}

Valgono inoltre i seguenti risulati, che sono conseguenze pressoch\`e
immediate del \TFA\footnote{In effetti, essi sono \emph{equivalenti}
a tale teorema, come vedremo tra poco.}:

\begin{theorem}\label{thm:TFA-div-p}
Se $p$ \`e primo e \,$p \divides ab$, allora \,$p \divides a$\, o
\,$p \divides b$.
\end{theorem}

\begin{theorem}\label{thm:TFA-div}
Se $m \divides ab$, ed\, $m$ ed\, $a$ sono coprimi, allora $m \divides b$.
\end{theorem}

\begin{theorem}\label{thm:TFA-mul-1}
Se $m$ \`e coprimo con $a$ e con $b$, allora esso \`e coprimo con $ab$.
\end{theorem}

\begin{theorem}\label{thm:TFA-mul-2}
Se $b$, $c$ sono coprimi ed entrambi dividono $a$, allora
anche $bc$ divide $a$.
\end{theorem}

Usando il teorema di divisione ed il principio di induzione, possiamo
offrire dimostrazioni di questi teoremi rimarchevolmente semplici, ed
indipendenti dal \TFA.
%
\begin{proof}[Dimostrazione del teorema~\eqref{thm:TFA-mul-2}]
%
Procediamo per induzione su $a$.  La tesi \`e immediata per $a = 0$ o
$a = 1$.  Supponendo ora $a > 1$, siano $b$ e $c$ due interi coprimi
che dividano entrambi $a$:%
  \vspace*{-5pt}%
\begin{equation}\label{eq: b|a e c|a}
a = bu \qquad\textrm{e}\qquad a = cv
  \vspace*{-5pt}%
\end{equation}

Vediamo prima il caso $bc \geq a$. Dal teorema di divisione abbiamo che
$bc = aq + r$, con $0 \leq r < a$.  Poich\`e $b \divides a$, abbiamo
anche $b \divides bc - aq = r$, e similmente $c \divides r$.  Per
induzione (essendo $r < a$) si ha dunque $bc \divides r$. Ma $bc \geq
a > r$, quindi necessariamente $r = 0$. Allora $bc = aq$, da cui,
usando~\eqref{eq: b|a e c|a}, otteniamo $c = uq$ e $b = vq$.  Dunque $q$
divide sia $b$ che $c$, ed essendo questi coprimi, necessariamente
$q = 1$, da cui $bc = aq = a$, ossia \emph{a~fortiori}
\,$bc \divides a$.

\smallskip
Vediamo ora il caso $bc < a$. Usando ancora il teorema di divisione,
possiamo scrivere $a = (bc)q + r$, con $0 \leq r < bc$\footnote{Si
noti che $q$ ed $r$ non sono pi\`u gli stessi di prima, ma preferiamo
riutilizzare comunque gli stessi simboli, per evitare inutili
appesantimenti.}. Poich\`e $b$ e $c$ dividono entrambi $a$, abbiamo
che essi dividono entrambi $r = a - bcq$, quindi per induzione
(essendo $r < bc < a$) si ha $bc \divides r$, da cui
$bc \divides \p{bcq + r} = a$.
%
\end{proof}

\begin{proof}[Dimostrazione del teorema~\eqref{thm:TFA-div}]
Chiaramente $a \divides ab$, ed inoltre $m \divides ab$ per ipotesi.
Allora, essendo $a$ ed $m$ coprimi, per il teorema~\eqref{thm:TFA-mul-2}
si ha che $am \divides ab$, da cui si ricava facilmente $m \divides b$.
\end{proof}

\begin{proof}[Dimostrazione del teorema~\eqref{thm:TFA-mul-1}]
Sia $d$ un intero che divide sia $m$ che $ab$.  Allora $d$ \`e primo
con $a$ (altrimenti ogni loro divisore comune $> 1$ dividerebbe sia
$m$ che $a$, assurdo), e quindi, essendo $d \divides ab$, deriva dal
teorema~\eqref{thm:TFA-div} che $d \divides b$.  Ma allora $d$ divide
sia $b$ che $m$, ed essendo questi coprimi, $d$ \`e necessariamente
$= 1$. Perci\`o $m$ ed $ab$ sono coprimi.
\end{proof}

Infine, il teorema~\eqref{thm:TFA-mul-1} implica come semplice corollario
il teorema~\eqref{thm:TFA-div-p}, ed il \TFA{} segue a sua volta quasi
immediatamente dal teorema~\eqref{thm:TFA-div-p}.

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\section{Massimo comun divisore e algoritmo di Euclide}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Massimo comun divisore: definizione e propriet\`a di base}

Si dice \emph{massimo comun divisore} di due interi $a$ e $b$ (anche
negativi) il massimo intero positivo $d$ che divida sia $a$ che $b$.
In tal caso si scrive $d = \gcd{a}{b}$.  Se almeno uno tra $a$ o $b$
\`e diverso da zero, \`e chiaro che $d$ esiste (per esempio, assumendo
$a \neq 0$, ogni divisore comune di $a$ e $b$ dev'essere minore o
uguale ad $\abs{a}$).  D'altra parte, per evitare problemi, si pone
per definizione $\gcd{0}{0} := 0$.

Una prima ovvia propriet\`a \`e che $\gcd{a}{b} = \gcd{\abs{a}}{\abs{b}}$;
ci\`o permette spesso di fare calcoli e dimostrazioni riferendosi soltanto
ad interi positivi, ma ottenendo risultati che valgono anche per gli
interi negativi.

Un'importantissima propriet\`a del massimo comun divisore \`e che, se
$m$ \`e un intero che divide sia $a$ che $b$, allora $m$ divide anche
$\gcd{a}{b}$\footnote{Questa \`e una conseguenza del lemma di B\'ezout,
che dimostreremo pi\`u avanti.}. D'altra parte, \`e ovvio che se $m$ \`e 
un intero che divide $d = \gcd{a}{b}$, allora esso divide sia $a$ che $b$
(poich\`e $d$ \`e un divisore comune ad essi).  Quindi, in un certo senso,
il massimo comun divisore ``contiene'' tutti gli altri divisori comuni.

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{L'algoritmo di Euclide}

Dati due interi positivi\footnote{Quanto segue potrebbe essere facilmente
generalizzato anche ad interi negativi, ma noi ci limiteremo a trattare
interi positivi per non appesantire troppo la discussione} $a$ e $b$,
\`e possibile calcolare il loro massimo comun divisore con
l'\emph{algoritmo di Euclide}, che consiste in una serie di divisioni
\emph{intere} (cio\`e con quoziente e resto) successive:

\begin{displaymath}
  \begin{array}{rcll}
      r_0  & \!=\! & a \\
      r_1  & \!=\! & b \\
      r_0  & \!=\! & r_1 q_0 + r_2\,, & 0 < r_2 < r_1 \\
      r_1  & \!=\! & r_2 q_1 + r_3\,, & 0 < r_3 < r_2 \\
    \ldots &       & \ldots \\
   r_{n-1} & \!=\! & r_{n} q_{n-1} + r_{n+1}\,, & 0 < r_{n+1} < r_{n} \\
     r_{n} & \!=\! & r_{n+1} q_{n}\,, & r_{n+2} = 0 \\
  \end{array}
\end{displaymath}

Prima di tutto, siccome gli $r_i$ sono strettamente decrescenti al
crescere di $i$, prima o poi si raggiunger\`a un $i$ con $r_i = 0$,
quindi effettivamente l'algoritmo termina sempre.  Inoltre, \emph{l'ultimo
resto $\neq 0$} (cio\`e $r_{n+1}$) \emph{\`e il massimo comun divisore di
$a$ e $b$}, come ora dimostreremo.

\begin{proof}
Se $a = bq + r$, allora \`e facile vedere che ogni intero che divide
$a$ e $b$ divide anche $r$, e similmente che ogni intero che divide $b$
ed $r$ divide anche $a$.  Quindi l'insieme dei divisore comuni di $a$ e
$b$ concide con l'insieme de divisori comuni di $b$ ed $r$, e perci\`o
$\gcd{a}{b}$ (che \`e il massimo del primo insieme) \`e uguale a
$\gcd{b}{r}$ (che \`e il massimo del secondo insieme).

\smallskip
\noindent
Dunque, riprendendo la catena di divisioni dell'algoritmo, avremo:
\begin{eqnarray*}
  \gcd{a}{b}
    & =
    & \gcd{r_0}{r_1} = \gcd{r_1}{r_2} = \gcd{r_2}{r_3} = \ldots \\
  \ldots
    & =
    & \gcd{r_n}{r_{n+1}} = r_{n+1}
\end{eqnarray*}
dove l'ultima uguaglianza deriva dal fatto che $r_{n+1} \divides r_n$.
\end{proof}

\noindent
\TODO: Magari mostrare efficienza dell'algoritmo di Euclide?

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Il Lemma di B\'ezout}

\begin{theorem}[Lemma di B\'ezout]\label{thm:lemma-bezout}
Se $d = \gcd{a}{b}$, allora esistono interi $x$ e $y$ (che possono
anche essere negativi) tali che $ax + by = d$.
\end{theorem}
%
\begin{proof}
Dimostriamo per induzione su $m$ che ogni resto $r_m$ nell'algoritmo
di Euclide \`e rappresentabile come $ax_m + by_m$ per opportuni interi
$x_m$, $y_m$. Ci\`o \`e evidente nei casi $m = 0$ ($r_0 = a = a \cdot 1 +
b \cdot 0$) e $m = 1$ ($r_1 = b = a \cdot 0 + b \cdot 1$). Assumendo poi
che la tesi sia vera per $m - 2$ ed $m - 1$, abbiamo:
\begin{eqnarray*}
r_m & = & r_{m-2} - r_{m-1} q_{m-2} = ax_{m-2} + by_{m-2} -
                                      \p{ax_{m-1} + by_{m-1}} q_{m-2} \\
& = &
a\p{x_{m-2} - q_{m-2}x_{m-1}} + b\p{y_{m-2} - q_{m-2}y_{m-1}}
\end{eqnarray*}
coiscch\`e la tesi \`e vera anche per $m$.  Poich\`e $\gcd{a}{b} =
r_{n+1}$, abbiamo finito.
\end{proof}

Si noti che la dimostrazione precedente offre in effetti un algoritmo
pratico (iterativo) per il calcolo di  $x$ ed $y$ (algoritmo che \`e in
effetti un'estensione dell'algoritmo di Euclide applicato ad $a$ e $b$,
ed \`e perci\`o noto col nome di \emph{algoritmo di Euclide esteso}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Aritmetica modulare}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Congruenze e operazioni modulo $m$}

\begin{definition}
Dato un intero positivo $m$ e due interi qualunque $a$ e $b$, si dice che
\emph{$a$ \`e congruente a $b$ modulo $m$}, e si scrive $a \congruent b
\mmod m$, se $m \divides \p{a - b}$, ossia se $a = b + tm$ per qualche
intero $t$.
\end{definition}

La relazione di congruenza modulo $m$ \`e una \emph{relazione di
equivalenza}, ossia:
\begin{enumerate}
\item $a \congruent a \mmod m$
\item $a \congruent b \mmod m \implies b \congruent a \mmod m$
\item $a \congruent b \mmod m ~\:\textrm{e}\:~
       b \congruent c \mmod m \implies
       a \congruent c \mmod m$
\end{enumerate}
La dimostrazione di queste tre propriet\`a \`e pressoch\`e immediata.

\smallskip
Ugualmente importante \`e il fatto che la relazione di congruenza
modulo $m$ \`e compatibile con le operazioni elementari:
%
\begin{theorem}\label{thm:modular-operation}
Se $a \congruent b \mmod m$ e\, $c \congruent d \mmod m$, allora
$a + c \congruent b + d \mmod m$, $a - c \congruent b - d \mmod m$,
$ac \congruent bd \mmod m$ e\, $a^n \congruent b^n \mmod m$.

\end{theorem}
%
\begin{proof}
Vediamo solo il caso della moltiplicazione (l'esponenziazione ne \`e
un corollario, addizione e sottrazione sono analoghi e pi\`u semplici).
Siccome $a \congruent b \mmod m$, risulta $m \divides \p{a - b}$,
quindi a fortiori $m \divides \p{a - b}c = ac - bc$, ossia
$ac \congruent bc \mmod m$.  Similmente si prova che, essendo
$c \congruent d \mmod m$, risulta $bc \congruent bd \mmod m$.
Allora, per transitivit\`a, $ac \congruent bd \mmod m$.
\end{proof}

Per la divisione abbiamo un risultato pi\`u debole, ma ugualmente
importante:
%
\begin{theorem}\label{thm:simplify-modulo-m}
Se $c$ ed $m$ sono coprimi, allora $ac \congruent bc \mmod m$ implica
che $a \congruent b \mmod m$.
\end{theorem}
%
\begin{proof}
Abbiamo che $ac \congruent bc \mmod m$, ossia $m \divides \p{a -b}c$.
Poich\`e $c$ ed $m$ sono coprimi, dal teorema~\eqref{thm:TFA-div}
segue che $m \divides \p{a -b}c$, \ie $a \congruent b \mmod m$.
\end{proof}

\begin{definition}
Un insieme di $m$ interi si dice \emph{sistema completo di residui modulo
$m$} se non ve ne sono due che siano congruenti tra loro modulo $m$.
\end{definition}

Il pi\`u semplice sistema completo di residui modulo $m$ \`e semplicemente
l'insieme $\set{0,\: 1,\: \ldots\: m - 1}$.

\smallskip
Vale il seguente risultato (che ci torner\`a utile pi\`u avanti):
%
\begin{theorem}\label{thm:complete-residue-system}
Se $A$ \`e un sistema completo di residui modulo $m$, allora per ogni
$i$ con $0 \leq i < m$ esiste uno ed uno solo $a_i \in A$ tale che
$a_i \congruent i \mmod m$.
\end{theorem}
%
\begin{proof}
Siano $a_0,\: \ldots\: a_{m-1}$ gli elementi di $A$, e siano $r_0,\:
\ldots\: r_{m-1}$ i rispettivi resti della divisione intera di quegli
elementi per $m$ (cosicch\`e $a_i \congruent r_i \mmod m$ per tutti
gli $i$).  Gli $r_i$ sono tutti distinti (se $r_h = r_k$ allora
$a_h \congruent a_k \mmod m$, e quindi $k = h$), e tutti compresi tra
$0$ ed $m - 1$ (essendo resti di una divisione per $m$); quindi, a
meno di un riodinamento, essi coincidono con gli interi $0,\: \ldots\:
m -1$.  Ma allora per ogni $i$ esiste un $r_i$ con $i = r_i$, e quindi
un $a_i \in A$ con $i \congruent r_i \congruent a_i \mmod m$.
L'unicit\`a di $a_i$ \`e poi ovvia.
\end{proof}

Il precedente teorema pu\`o essere usato facilmente per ottenere la
seguente generalizzazione:
%
\begin{corollary}\label{cor:complete-residue-system-basic}
Se $A$ e $B$ sono due sistemi completi di residui modulo $m$, allora per
ogni $a \in A$ esiste uno ed uno solo $b \in B$ tale che $a \congruent b
\mmod m$.
\end{corollary}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Un algoritmo per l'esponenziazione modulo $m$}

Il metodo pi\`u ``ingenuo'' per calcolare $a^n$ modulo $m$ consiste
semplicemente nell'effetuare $n$ moltiplicazioni e riduzioni modulo $n$
succesive, come espresso nel seguente pseudocodice (in cui \verb|x % y|
indica il resto della divisione intera di \verb|x| per \verb|y|):
%
\begin{verbatim}
    result = 1
    for i = 1, ... n:
        result = (result * a) % m
\end{verbatim}

Ma \`e chiaro che questo algoritmo \`e piuttosto inefficiente, e risulta
inutilizzabile quando $n$ \`e grande, in quanto esso richiede $n$
moltiplicazioni.

Un metedo assai pi\`u efficiente deriva dalle seguenti relazioni
(pressoch\`e immediate, se non banali, da dimostrare):
\begin{eqnarray}
  a^{2n}   & \congruent & \p{a^2\:\mmodop\:m}^m \mmod m
    \label{eq:sq-mul-even}
  \\
  a^{2n+1} & \congruent & a \p{a^2\:\mmodop\:m}^m \mmod m
    \label{eq:sq-mul-odd}
\end{eqnarray}
%
Eccolo in dettaglio:
\begin{algorithm}[Elevazione a potenza con metodo ``square and multiply'']
Dati un intero $a$ ed un esponente $n > 0$, definiamo ricorsivamente le
tre sequenze di numeri $b_i$, $e_i$, ed $f_i$ come segue:
\begin{displaymath}
  \begin{array}{lll}
    e_0 := n &
    b_0 := a &
    f_0 := 1
  \\
    e_{i+1} := \left\lfloor{\frac{e_i}{2}}\right\rfloor ~~ &
    b_{i+1} := {b_i}^2\:\mmodop\:m ~~ &
    f_{i+1} := \begin{cases}
             f_i & \text{se $e_i$ pari} \\
             f_i b_i \:\mmodop\: m & \text{se $e_i$ dispari}
           \end{cases}
  \end{array}
\end{displaymath}
Le sequenze si fermano all'ultimo indice $k$ con $e_k > 0$.  Per tale
$k$, risulta $e_k = 1$ e $a^m \congruent b_k f_k \mmod m$.  Inoltre,
$k \leq log_2 n$.
\end{algorithm}

\begin{proof}
Usando~\eqref{eq:sq-mul-even} e~\eqref{eq:sq-mul-odd}, si dimostra
facilmente per induzione che, ad ogni passo, $a^m \congruent b_i f_i
\mmod m$, da cui la prima parte della tesi ponendo $i = k$.  Inoltre,
se fosse $e_k \geq 2$, avremmo $e_{k+1} \geq 1$, e $k$ non sarebbe
l'ultimo indice con $e_k > 0$, assurdo.  Infine, \`e evidente che
per ogni indice $i$ si ha $e_{i+1} \leq \frac{e_i}{2}$, da cui segue
facilmente per induzione che $2^i e_i \leq e_0 = n$, e quindi che
$2^k = 2^k e_k \leq n \implies k \leq log_2 n$.
\end{proof}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Inverso modulo $m$}

\begin{definition}
Dato un intero $a$, il suo inverso secondo il modulo $m$, \`e quell'intero
$b$ (se esiste) tale che $ab \congruent 1 \mmod m$.
\end{definition}

Non \`e detto che l'inverso di $a$ esista, ma se esiste \`e unico modulo $m$
(ossia due qualunque inversi di $a$ sono congruenti tra loro modulo $m$).
Precisamente, abbiamo il seguente risultato:

\begin{theorem}
Un intero $a$ (positivo o negativo) ha un inverso modulo $m$ se e solo se
$\gcd{a}{m} = 1$.  In tal caso, tale inverso \`e unico modulo $m$.
\end{theorem}

\`E chiaro che $a$ dev'esse coprimo con $m$ per avere un inverso, poich\`e
l'avere $ab \congruent 1 \mmod m$ implica che ogni divisore comune di $a$
ed $m$ divide anche $1$, e pu\`o quindi essere solo l'unit\`a stessa.

\medskip\noindent
Vediamo ora di dimostrare le altre parti del teorema.

\begin{proof}[Dimostrazione di unicit\`a]
Siano $x, y$ tali che $ax \congruent 1 \mmod m$ e $ay \congruent 1
\mmod m$; allora $ax \congruent ay \mmod m$, e quindi per il
teorema~\eqref{thm:simplify-modulo-m} abbiamo che $x \congruent y
\mmod m$.
\end{proof}

\begin{proof}[Prima dimostrazione di esistenza]
Sia $a$ un intero coprimo con $m$, e sia $X := \setdef{ab}{b = 0,\: 1,\:
\ldots\: m - 1}$. $X$ \`e chiaramente un sistema completo di residui modulo
$m$, in quanto contiene $m$ elementi, e nessuno di essi \`e congruente ad
un altro modulo $m$ (in virt\`u del teorema~\eqref{thm:simplify-modulo-m}).
Dal teorema~\eqref{thm:complete-residue-system} segue quindi che esiste un
$x \in X$ con $x \congruent 1 \mmod m$; poich\`e $x = ab$, $b$ \`e inverso
di $a$ modulo $m$.
\end{proof}

\begin{proof}[Seconda dimostrazione di esistenza]
Sia $a$ un intero coprimo con $m$.  Allora $\gcd{a}{m} = 1$, quindi per il
lemma di B\'ezout esistono due interi $x$ ed $y$ tali che $ax + my = 1$,
da cui $ax \congruent 1 \mmod m$.
\end{proof}

La seconda dimostrazione di esistenza ha il vantaggio di fornire un
algoritmo pratico ed efficiente per il calcolo degli inversi modulo $m$
(poich\`e $x$ pu\`o essere calcolato esplicitamente con l'algoritmo di
Euclide esteso).

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Il teorema di Fermat}

\begin{theorem}[Teorema di Fermat]\label{thm:fermat}
Sia $p$ un numero primo. Allora, per ogni $a \in \Z$ con, si ha
$a^p \congruent a \mmod m$.  In particolare, se $p \notdivides a$,
risulta $a^{p-1} \congruent 1 \mmod m$.
\end{theorem}

Si noti che la seconda parte della tesi segue immediatamente dalla prima.
Infatti, $a^p \congruent a \mmod m$ implica $a\p{a^{p-1} - 1} \congruent
0 \mmod m$, e se $p \notdivides a$, abbiamo (essendo $p$ primo) che
$a$ e $p$ sono coprimi, cosicch\`e il teorema~\eqref{thm:TFA-div} ci
permette di concludere che $a^{p-1} - 1 \congruent 0 \mmod m$.

\bigskip
\noindent
Offriremo ora due dimostrazioni alternative della prima parte della tesi.

\begin{proof}[Dimostrazione ``standard'' del teorema di Fermat]
%
Innanzitutto, dal corollario~\eqref{cor:complete-residue-system-basic}
e dal teorema~\eqref{thm:modular-operation}, segue facilmente che se
$R$ ed $S$ sono due sistemi completi di residui modulo $p$ si ha:
\begin{equation}\label{eq:product-complete-residue-system}
  \prod_{\substack{r \in R\\ r \not\congruent 0 \mmod p}}\!\!\!\! r
  \quad\congruent
  \prod_{\substack{s \in S\\ s \not\congruent 0 \mmod p}}\!\!\!\! s
  \quad\mmod p
\end{equation}

Sia ora $a$ un intero non divisibile per $p$. Allora $a$ \`e primo con
$p$, da cui segue che $ax \not\congruent ay \mmod a$ se $x \not\congruent
y \mmod m$. Dunque l'insieme $\setdef{ax}{0 \leq x \leq p}$ \`e un
sistema completo di residui modulo $m$, cosicch\`e
da~\eqref{eq:product-complete-residue-system} deriva:
\begin{displaymath}
  \prod_{1 \leq x \leq p} ax \congruent \prod_{1 \leq x \leq p} a \mmod m
\end{displaymath}
ossia:
\begin{displaymath}
  (p-1)!\: a^{p-1} \congruent (p-1)! \mmod m
\end{displaymath}
da cui essendo $(p - 1)!$\, primo con $p$ (in quanto prodotto di numeri
tutti primi con $p$) si ottiene che $a^{p-1} \congruent 1 \mmod m$, da cui
$a^p \congruent a \mmod m$.

D'altra parte, se $a$ \`e invece un intero divisibile per $p$, si ha
$a^p \congruent 0^p = 0 \congruent a \mmod p$, e la tesi \`e vera anche
in questo caso.
%
\end{proof}

\noindent
Per la seconda dimostrazione, ci serve un lemma preliminare:

\begin{xlemma}
Se $p$ \`e primo e, $0 < k < p$, allora $p \divides \binom{p}{k}$.
\end{xlemma}
%
\begin{proof}
Sappiamo che:
  $$\binom{p}{k} = \frac{p!}{k! (p - k)!}$$
\`e un intero, cosicch\`e $k!\,(p - k)! \divides p! = p \cdot (p - 1)!$\,.
Essendo $p$ primo, $k!\,(p - k)!$ \`e prodotto di interi positivi tutti
$< p$, e quindi primi con $p$; dunque $k!\,(p - k)!$ \`e anch'esso primo
con $p$ in virt\`u del teorema dal teorema~\eqref{thm:TFA-mul-1}.
Allora dal teorema~\eqref{thm:TFA-div} deriva che $k! (p - k)! \divides
(p - 1)!$, quindi, detto $\frac{(p - 1)!}{k!\,(p - k)!}= m$, si ha
$\binom{p}{k} = pm$, e quindi $p \divides \binom{p}{k}$.
\end{proof}

\begin{proof}[Dimostrazione induttiva del Teorema di Fermat]
\`E chiaro che ci basta dimostrare la tesi per $a \geq 0$.  Procediamo
dunque per induzione su $a$, i casi $a = 0$ e $a = 1$ essendo banali.
Usando il teorema binomiale abbiamo:
\begin{displaymath}
  \p{a+1}^p = a^p + \sum_{k=1}^{p-1} \binom{p}{k}a^{p-k} + 1
\end{displaymath}
Per il lemma precedente, tutti i termini della sommatoria sono divisibili
per $p$; inoltre, per l'ipotesi induttiva, $a^p \congruent a \mmod p$.
Quindi:
\begin{displaymath}
  \p{a+1}^p \congruent a^p + \sum_{k=1}^{p-1} 0 + 1
            \congruent a + 1 \mmod m
\end{displaymath}
e la tesi \`e dunque vera anche per $a + 1$.
\end{proof}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Funzione $\phi$ e teoremi di Eulero}

\TODO: Funzione $\phi$ di Eulero: defn and properties.

La funzione di Eulero permette di ottenerare una nota generalizzazione
del teorema di Fermat\footnote{La cui dimostrazione ricalca la nostra
seconda dimostrazione del teorema di Fermat.}:

\begin{theorem}[Teorema di Eulero]\label{thm:euler}
  Sia $m$ un intero positvo. Allora, per ogni $a \in \Z$ con
  $\gcd{a}{m} = 1$, risulta\, $a^{\phi(m)} \congruent 1 \mmod m$.
\end{theorem}

\noindent
Ma a noi interessa una diversa (e meno nota) generalizzazione:

\begin{theorem}[Teorema di Eulero per RSA]\label{thm:euler-rsa}
Se $m$ \`e prodotto di due primi \emph{distinti}, allora risulta
$a^{\phi(m)} \congruent a \mmod m$ per \emph{ogni} intero $a$ (anche
non coprimo con $m$).
\end{theorem}
%
\begin{proof}
Sia $a$ un intero qualunque.  Allora, se $p \notdivides a$, dal teorema
di Fermat deriva che $a^{p-1} \congruent 1 \mmod p$, e quindi
$a^{\phi(m)} = a^{(p-1)(q-1)} = {\p{a^{p-1}}}^{q-1} \congruent 1^{q-1}
\congruent 1 \mmod p$.  D'altra parte, se $p \divides a$, allora
$a^{\phi(m)} \congruent 0^{\phi(m)} = 0 \congruent a \mmod p$.  In ogni
caso, $a^{\phi(m)} \congruent a \mmod p$.  Similamente, $a^{\phi(m)}
\congruent a \mmod q$, e quindi, essendo $p$ e $q$ coprimi (in quanto
primi distinti), $a^{\phi(m)} \congruent a \mmod{pq}$, ossia $\mmod m$.
\end{proof}

In effetti, il teorema qui sopra \`e valido per ogni intero $m$
\emph{libero da quadrati}, e la dimostrazione di ci\`o \`e una
semplice generalizzazione di quella appena data.  Ma per i nostri
scopi il caso $m = pq$ \`e sufficiente, quindi non ci soffermeremo
oltre.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Il crittosistema RSA}

\subsection{Generalit\`a}

Crittografia a chiave pubblica (trap function? Diffie-Hellmann?).
RSA: basato su semplici operazioni di aritmetica modulare. Opera su
interi di grandezza limitata; spiegare come generiche sequenze di
bytes possono essere convertite da/a proprie sequenze di interi
eligibili per essere processati da RSA.

\subsection{Basi teoriche}

Il fondamento del crittosistem \'e offerto dal seguente semplice
corollario del teorema di Eulero:

\TODO: come criptare/decriptare un intero con RSA.
\TODO: simmetria fra criptazione e decriptazione.

\subsection{Un esempio basilare dell'uso di RSA}

\TODO: see \verb+http://en.wikipedia.org/wiki/RSA#A_working_example+

\subsection{Schemi di padding a attachi ad RSA}

When used in practice, RSA is generally combined with some padding scheme.
The goal of the padding scheme is to prevent a number of attacks that
potentially work against RSA without padding:\\
\TODO: copia da wikipedia?

LINKS:\\
~~~\verb+http://en.wikipedia.org/wiki/RSA#Padding_schemes+\\
~~~\verb+http://en.wikipedia.org/wiki/Optimal_Asymmetric_Encryption_Padding+
~~~\verb+http://en.wikipedia.org/wiki/Random_oracle_model+

\subsection{Firme digitali con RSA (cenni)}

\XXX[TODO ALL]

\noindent Vedi anche:
\verb+http://en.wikipedia.org/wiki/Cryptographic_hash_function+

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{??? La nostra implementazione del crittosistema RSA in python}

\XXX[TODO ALL]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

% vim: ft=tex et ts=2 sw=2
