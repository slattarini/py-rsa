% -*- LaTeX -*-

\newif\ifoneside
\onesidetrue

\newif\ifuselinks
\uselinkstrue

\IfFileExists{RSA-ifuselinks.tex}{\input{RSA-ifuselinks.tex}}{}

\ifoneside
  \documentclass[pdflatex,11pt,a4paper,oneside]{article}
\else
  \documentclass[pdflatex,11pt,a4paper]{article}
\fi

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\usepackage{fancyhdr}
\usepackage{verbatim}
\usepackage{amsfonts,mathrsfs,amsmath,amssymb,amstext,amsthm}
\usepackage{xcolor}

\usepackage[perpage,symbol]{footmisc}

% hyperref should be the last package to be loaded.
\ifuselinks\usepackage{hyperref}\fi

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\newcommand{\theauthor}[0]{Stefano Lattarini}
\newcommand{\thetitle}[0]{Cenni teorici sul crittosistema RSA}

\renewcommand{\phi}{\varphi}

\newcommand{\bzl}{B\'ezout's lemma} %XXX
\newcommand{\gel}{generalized Euclid's lemma} %XXX
\newcommand{\ethm}{Teorema di Eulero}
\newcommand{\fthm}{Teorema di Fermat}
\newcommand{\ephif}{Funzione $\phi$ di Eulero}
\newcommand{\crmdt}{Teorema Cinese del Resto}

\newcommand{\XXX}[1][XXX]{\text{\bfseries{\color{red}{\emph{#1}}}}}
\newcommand{\TODO}[0]{\XXX[TODO]}
\newcommand{\FIXME}[0]{\XXX[FIXME]}

\newcommand{\acro}[1]{\text{{\frenchspacing {#1} }}}
\newcommand{\ie}[0]{\acro{i.e.}}
\newcommand{\eg}[0]{\acro{e.g.}}
\newcommand{\tc}[0]{\acro{t.c.}}
\newcommand{\wrt}[0]{\acro{w.r.t}}

\newcommand{\p}[1]{\left({#1}\right)}
\newcommand{\q}[1]{\left({#1}\right)^2}
\newcommand{\abs}[1]{\left|{#1}\right|}
\newcommand{\card}[1]{\abs{#1}}
\newcommand{\varcard}[2][\,]{\pmb{\#}{#1}{#2}}

\newcommand{\N}[0]{\mathbb{N}}
\newcommand{\Z}[0]{\mathbb{Z}}

\newcommand{\divides}[0]{\mid}
\newcommand{\notdivides}[0]{\nmid}

\newcommand{\congruent}[0]{\equiv}
\newcommand{\notcongruent}[0]{\not\equiv}
\newcommand{\mmodop}[0]{\ensuremath{\operatorname{mod}}}
\newcommand{\mmod}[1]{\ensuremath{\allowbreak\ (\mmodop\:{#1})}}
\newcommand{\xmod}[1]{\ensuremath{\allowbreak\ \left(\mmodop\:{#1}\right)}}

\newcommand{\cc}[2][m]{\ensuremath{\left[\:{#2}\,\right]_{\,#1}}}

\newcommand{\iseq}[1]{\ensuremath{0,\,1,\,\ldots,\, {#1} - 1}}
\newcommand{\set}[1]{\ensuremath{\left\{\,{#1}\,\right\}}}
\newcommand{\setdef}[2]{\set{{#1}:\:{#2}}}

\newcommand{\gcdop}[0]{\ensuremath{\operatorname{g.c.d.}}}
\newcommand{\xgcd}[1]{\ensuremath{\gcdop\left({#1}\right)}}
\renewcommand{\gcd}[2]{\xgcd{{#1},\,{#2}}}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\newtheorem{TheoremLike}{\XXX}
\newtheorem{algorithm}[TheoremLike]{Algorithm}
\newtheorem{*xalgorithm}{Algorithm}
\newtheorem{theorem}[TheoremLike]{Theorem}
\newtheorem*{xtheorem}{Theorem}
\newtheorem{definition}[TheoremLike]{Definition}
\newtheorem*{xdefinition}{Definition}
\newtheorem{lemma}[TheoremLike]{Lemma}
\newtheorem*{xlemma}{Lemma}
\newtheorem{corollary}[TheoremLike]{Corollary}
\newtheorem*{xcorollary}{Corollary}
\newtheorem{proposition}[TheoremLike]{Proposition}
\newtheorem*{xproposition}{Proposition}
\newtheorem{example}[TheoremLike]{Example}
\newtheorem*{xexample}{Example}
\newtheorem{property}[TheoremLike]{Property}
\newtheorem*{xproperty}{Property}
\newtheorem{remark}[TheoremLike]{Remark}
\newtheorem*{xremark}{Remark}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markright{\thesection~\:#1}}
\fancyhf{} % clear all header fields
\fancyhead[RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\ifoneside
  \relax
\else
  \fancyhead[RE]{\bfseries\leftmark}
  \fancyhead[LE]{\bfseries\thepage}
\fi
\fancyfoot{} % clear all footer fields
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{0.5pt}
\fancypagestyle{plain}{
  \fancyhf{} % clear all header and footer fields
  \fancyfoot[C]{\bfseries \thepage} % except the center
  \renewcommand{\headrulewidth}{0pt}
  \renewcommand{\footrulewidth}{0pt}
}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\DefineFNsymbols*{myftnsymbol}{%
  \dagger%
  \ddagger%
  \S%
  \sharp%
  \clubsuit%
  \spadesuit%
  \P%
}

\setfnsymbol{myftnsymbol}

\ifuselinks
  \hypersetup{
    backref,
    pdftitle={\thetitle},
    pdfauthor={\theauthor}
    pdfborder={0 0 0},
    anchorcolor=green,
    colorlinks,
    linkcolor=blue,
    pdfpagelabels
  }
\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title{\thetitle}
\author{\theauthor}
%\date{YEAR-MONTH-DAY}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
  Cenni di teoria circa la nostra implementazione didattica del
  crittosistema RSA.  Si assume una conoscenza di base dell'aritmetica
  teorica -- e.g., definizione e semplici propriet\`a dei numeri primi
  e composti, teorema fondamentale dell'aritmetica, divisione con resto,
  eccetera.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Nozioni preliminari}

Le nozioni qui riportate dovrebbero essere ben note, quindi le
passeremo in rassegna molto velocemente, solo per avere rifrimenti
facilmente accessibile nel seguito.

Teorema di divisione: quoziente e resto.

Numeri primi e numeri composti.  Numeri coprimi ovvero primi tra loro.

Teorema fondamentale dell'aritmetica e risulati correlati (se $p$ \`e
primo e $p \divides ab$ allora $p \divides a$ o $p \divides b$; se
$m \divides ab$ e $m$ ed $a$ sono coprimi, allora $m \divides b$; se
$a$ e $b$ sono coprimi ed entrambi dividono $c$, allora $ab \divides c$).

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\section{Massimo comun divisore e algoritmo di euclide}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Massimo comun divisore: definizione e propriet\`a di base}

Si dice \emph{massimo comun divisore} di due interi $a$ e $b$ (anche
negativi) il massimo intero positivo $d$ che divida sia $a$ che $b$.
In tal caso si scrive $d = \gcd{a}{b}$.  Se almeno uno tra $a$ o $b$
\`e diverso da zero, \`e chiaro che $d$ esiste (per esempio, assumendo
$a \neq 0$, ogni divisore comune di $a$ e $b$ dev'essere minore o
uguale ad $\abs{a}$).  D'altra parte, per evitare problemi, si pone
per definizione $\gcd{0}{0} := 0$.

Una prima ovvia propriet\`a \`e che $\gcd{a}{b} = \gcd{\abs{a}}{\abs{b}}$;
ci\`o permette spesso di fare calcoli e dimostrazioni riferendosi soltanto
ad interi positivi, ma ottenendo risultati che valgono anche per gli
interi negativi.

Enunciamo a questo punto un'importante propriet\`a del massimo comun
divisore: se $d = \gcd{a}{b}$, ed $m$ \`e un intero che divide sia $a$
che $b$, allora $m$ divide anche $d$\footnote{Questa \`e una conseguenza
del lemma di Bezout, che dimostreremo pi\`u avanti.}. D'altra parte, \`e
ovvio che se $m$ \`e un intero che divide $d$, allora esso divide sia $a$
che $b$. Quindi, in un certo senso, il massimo comun divisore ``contiene''
tutti gli altri divisori comuni.

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{L'algoritmo di euclide}

Dati due interi positivi\footnote{Quanto segue potrebbe essere facilmente
generalizzato anche ad interi negativi, ma noi ci limiteremo a trattare
interi positivi per non appesantire troppo la discussione} $a$ e $b$,
\`e possibile calcolare il loro massimo comun divisore con
l'\emph{algoritmo di Euclide}, che consiste in una serie di divisioni
\emph{intere} (cio\`e con quoziente e resto) successive:

\begin{displaymath}
  \begin{array}{rcll}
      r_0  & \!=\! & a \\
      r_1  & \!=\! & b \\
      r_0  & \!=\! & r_1 q_0 + r_2\,, & 0 < r_2 < r_1 \\
      r_1  & \!=\! & r_2 q_1 + r_3\,, & 0 < r_3 < r_2 \\
    \ldots &       & \ldots \\
   r_{n-1} & \!=\! & r_{n} q_{n-1} + r_{n+1}\,, & 0 < r_{n+1} < r_{n} \\
     r_{n} & \!=\! & r_{n+1} q_{n}\,, & r_{n+2} = 0 \\
  \end{array}
\end{displaymath}

Prima di tutto, siccome gli $r_i$ sono strettamente decrescenti al
crescere di $i$, prima o poi si raggiunger\`a un $i$ con $r_i = 0$,
quindi effettivamente l'algoritmo termina sempre.  Inoltre, \emph{l'ultimo
resto $\neq 0$} (cio\`e $r_{n+1}$) \emph{\`e il massimo comun divisore di
$a$ e $b$}, come ora dimostreremo.

\begin{proof}
Se $a = bq + r$, allora \`e facile vedere che ogni intero che divide
$a$ e $b$ divide anche $r$, e similmente che ogni intero che divide $b$
ed $r$ divide anche $a$.  Quindi l'insieme dei divisore comuni di $a$ e
$b$ concide con l'insieme de divisori comuni di $b$ ed $r$, e perci\`o
$\gcd{a}{b}$ (che \`e il massimo del primo insieme) \`e uguale a
$\gcd{b}{r}$ (che \`e il massimo del secondo insieme).

\smallskip
\noindent
Dunque, riprendendo la catena di divisioni dell'algoritmo, avremo:
\begin{eqnarray*}
  \gcd{a}{b}
    & =
    & \gcd{r_0}{r_1} = \gcd{r_1}{r_2} = \gcd{r_2}{r_3} = \ldots \\
  \ldots
    & =
    & \gcd{r_n}{r_{n+1}} = r_{n+1}
\end{eqnarray*}
dove l'ultima uguaglianza deriva dal fatto che $r_{n+1} \divides r_n$.
\end{proof}

\noindent
\TODO: Magari mostrare efficienza dell'algoritmo di euclide?

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Il Lemma di B\'ezout}

Se $d = \gcd{a}{b}$, allora esistono interi $x$ e $y$ (che possono 
anche essere negativi) tali che $ax + by = d$ (Lemma di B\'ezout).

La cosa importante \`e che $x$ e $y$ possono essere calcolati
efficientemente dall'algoritmo di euclide per $a$ e $b$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Aritmetica modulare}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Congruenze e operazioni modulo $m$}

Definizione congruenza modulo $m$.

\`E una relazione di equivalenza.

Definizione di sistema complete di residui modulo $m$.

Altre propriet\`a ($ax \congruent bx \implies a \congruent b$).

Operazioni modulo $m$.

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Esponenziazione modulo $m$}

Algoritmo ottimizzato (``square-and-multiply''), che abbiamo usato nella
nostra implementazion python.

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Inverso modulo $m$}

Inverso di $a$ secondo il modulo $m$: intero $x$ tale che
$ax \congruent 1 \mmod m$.

Un intero $a$ (positivo o negativo) ha un inverso modulo $m$ se e solo se
$\gcd{a}{m} = 1$; \TODO: dimostrare (usare Bezout).

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Il ``piccolo'' teorema di Fermat}

``Piccolo'' teorema di Fermat (due dimostrazioni; la seconda non dipende
dall'esistenza dell'inverso modulo $m$, e pu\`o offire una dimostrazione
alternativa).

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Funzione $\phi$ e teoremi di Eulero}

\TODO: Funzione $\phi$ di Eulero: defn and properties.

La funzione di Eulero permette di ottenerare una nota generalizzazione
del teorema di Fermat\footnote{La cui dimostrazione ricalca la nostra
seconda dimostrazione del teorema di Fermat.}:

\begin{theorem}[Teorema di Eulero]\label{thm:euler}
  Sia $m$ un intero positvo. Allora, per ogni $a \in \Z$ con
  $\gcd{a}{m} = 1$, risulta\, $a^{\phi(m)} \congruent 1 \mmod m$.
\end{theorem}

\noindent
Ma a noi interessa una diversa (e meno nota) generalizzazione:

\begin{theorem}[Teorema di Eulero per RSA]\label{thm:euler-rsa}
Se $m$ \`e prodotto di due primi \emph{distinti}, allora risulta
$a^{\phi(m)} \congruent a \mmod m$ per \emph{ogni} intero $a$ (anche
non coprimo con $m$).
\end{theorem}
%
\begin{proof}
Sia $a$ un intero qualunque.  Allora, se $p \notdivides a$, dal teorema
di Fermat deriva che $a^{p-1} \congruent 1 \mmod p$, e quindi
$a^{\phi(m)} = a^{(p-1)(q-1)} = {\p{a^{p-1}}}^{q-1} \congruent 1^{q-1}
\congruent 1 \mmod p$.  D'altra parte, se $p \divides a$, allora
$a^{\phi(m)} \congruent 0^{\phi(m)} = 0 \congruent a \mmod p$.  In ogni
caso, $a^{\phi(m)} \congruent a \mmod p$.  Similamente, $a^{\phi(m)}
\congruent a \mmod q$, e quindi, essendo $p$ e $q$ coprimi (in quanto
primi distinti), $a^{\phi(m)} \congruent a \mmod{pq}$, ossia $\mmod m$.
\end{proof}

In effetti, il teorema qui sopra \`e valido per ogni intero $m$
\emph{libero da quadrati}, e la dimostrazione di ci\`o \`e una
semplice generalizzazione di quella appena data.  Ma per i nostri
scopi il caso $m = pq$ \`e sufficiente, quindi non ci soffermeremo
oltre.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Il crittosistema RSA}

\subsection{The RSA cryptosystem: theoretical foundations}

\TODO: Description and theoratical fundations; what are the cleartexts,
what are the cyphertexts, what are the keys.

\subsection{A working example of RSA}

\TODO: see \verb+http://en.wikipedia.org/wiki/RSA#A_working_example+

\subsection{Padding schemes and known attacks to RSA}

When used in practice, RSA is generally combined with some padding scheme.
The goal of the padding scheme is to prevent a number of attacks that
potentially work against RSA without padding:\\
\TODO: copy from wikipedia

\TODO: Very important about padding:\\
~~~\verb+http://en.wikipedia.org/wiki/RSA#Padding_schemes+\\
~~~\verb+http://en.wikipedia.org/wiki/Optimal_Asymmetric_Encryption_Padding+
~~~\verb+http://en.wikipedia.org/wiki/Random_oracle_model+

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Digital signatures with RSA}

\TODO: all

\TODO: see also:
\verb+http://en.wikipedia.org/wiki/Cryptographic_hash_function+

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Our python implementation of RSA cryptosystem}

\TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

% vim: ft=tex et ts=2 sw=2
