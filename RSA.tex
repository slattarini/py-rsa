% -*- LaTeX -*-

\newif\ifoneside
\onesidetrue

\newif\ifuselinks
\uselinkstrue

\IfFileExists{RSA-ifuselinks.tex}{\input{RSA-ifuselinks.tex}}{}

\ifoneside
  \documentclass[pdflatex,11pt,a4paper,oneside]{article}
\else
  \documentclass[pdflatex,11pt,a4paper]{article}
\fi

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\usepackage[italian]{babel}
\usepackage{fancyhdr}
\usepackage{verbatim}
\usepackage{amsfonts,mathrsfs,amsmath,amssymb,amstext,amsthm}
\usepackage{xcolor}

\usepackage[perpage,symbol]{footmisc}

% hyperref should be the last package to be loaded.
\ifuselinks\usepackage{hyperref}\fi

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\newcommand{\theauthor}[0]{Stefano Lattarini}
\newcommand{\thetitle}[0]{Cenni teorici sul crittosistema RSA}

\renewcommand{\phi}{\varphi}

\newcommand{\XXX}[1][XXX]{\text{\bfseries{\color{red}{\emph{#1}}}}}
\newcommand{\TODO}[0]{\XXX[TODO]}
\newcommand{\FIXME}[0]{\XXX[FIXME]}
\newcommand{\UNEXPANDED}[0]{\XXX[SHOULD-BE-UNEXPANDED]}

\newcommand{\acro}[1]{\text{{\frenchspacing {#1} }}}
\newcommand{\ie}[0]{\acro{i.e.}}
\newcommand{\eg}[0]{\acro{e.g.}}
\newcommand{\tc}[0]{\acro{t.c.}}

\newcommand{\p}[1]{\left({#1}\right)}
\newcommand{\q}[1]{\left({#1}\right)^2}
\newcommand{\abs}[1]{\left|{#1}\right|}
\newcommand{\card}[1]{\abs{#1}}
\newcommand{\varcard}[2][\,]{\pmb{\#}{#1}{#2}}

\newcommand{\N}[0]{\mathbb{N}}
\newcommand{\Z}[0]{\mathbb{Z}}

\newcommand{\divides}[0]{\mid}
\newcommand{\notdivides}[0]{\nmid}

\newcommand{\congruent}[0]{\equiv}
\newcommand{\notcongruent}[0]{\not\equiv}
\newcommand{\mmodop}[0]{\ensuremath{\operatorname{mod}}}
\newcommand{\mmod}[1]{\ensuremath{\allowbreak\ (\mmodop\:{#1})}}
\newcommand{\xmod}[1]{\ensuremath{\allowbreak\ \left(\mmodop\:{#1}\right)}}

\newcommand{\cc}[2][m]{\ensuremath{\left[\:{#2}\,\right]_{\,#1}}}

\newcommand{\iseq}[1]{\ensuremath{0,\,1,\,\ldots,\, {#1} - 1}}
\newcommand{\set}[1]{\ensuremath{\left\{\,{#1}\,\right\}}}
\newcommand{\setdef}[2]{\set{{#1}:\:{#2}}}

\newcommand{\gcdop}[0]{\ensuremath{\operatorname{g.c.d.}}}
\newcommand{\xgcd}[1]{\ensuremath{\gcdop\left({#1}\right)}}
\renewcommand{\gcd}[2]{\xgcd{{#1},\,{#2}}}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\newtheorem{TheoremLike}{\UNEXPANDED}
\newtheorem{algorithm}[TheoremLike]{Algoritmo}
\newtheorem{*xalgorithm}{Algoritmo}
\newtheorem{theorem}[TheoremLike]{Teorema}
\newtheorem*{xtheorem}{Teorema}
\newtheorem{definition}[TheoremLike]{Definizione}
\newtheorem*{xdefinition}{Definizione}
\newtheorem{lemma}[TheoremLike]{Lemma}
\newtheorem*{xlemma}{Lemma}
\newtheorem{corollary}[TheoremLike]{Corollario}
\newtheorem*{xcorollary}{Corollario}
\newtheorem{proposition}[TheoremLike]{Proposizione}
\newtheorem*{xproposition}{Proposizione}
\newtheorem{example}[TheoremLike]{Esempio}
\newtheorem*{xexample}{Esempio}
\newtheorem{property}[TheoremLike]{Propriet\`a}
\newtheorem*{xproperty}{Propriet\`a}
\newtheorem{remark}[TheoremLike]{Osservazione}
\newtheorem*{xremark}{Osservazione}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markright{\thesection~\:#1}}
\fancyhf{} % clear all header fields
\fancyhead[RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\ifoneside
  \relax
\else
  \fancyhead[RE]{\bfseries\leftmark}
  \fancyhead[LE]{\bfseries\thepage}
\fi
\fancyfoot{} % clear all footer fields
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{0.5pt}
\fancypagestyle{plain}{
  \fancyhf{} % clear all header and footer fields
  \fancyfoot[C]{\bfseries \thepage} % except the center
  \renewcommand{\headrulewidth}{0pt}
  \renewcommand{\footrulewidth}{0pt}
}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\DefineFNsymbols*{myftnsymbol}{%
  \dagger%
  \ddagger%
  \S%
  \sharp%
  \clubsuit%
  \spadesuit%
  \P%
}

\setfnsymbol{myftnsymbol}

\ifuselinks
  \hypersetup{
    backref,
    pdftitle={\thetitle},
    pdfauthor={\theauthor}
    pdfborder={0 0 0},
    anchorcolor=green,
    colorlinks,
    linkcolor=blue,
    pdfpagelabels
  }
\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title{\thetitle}
\author{\theauthor}
%\date{YEAR-MONTH-DAY}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
  Cenni di teoria circa la nostra implementazione didattica del
  crittosistema RSA.  Si assume una conoscenza di base dell'aritmetica
  teorica -- e.g., definizione e semplici propriet\`a dei numeri primi
  e composti, teorema fondamentale dell'aritmetica, divisione con resto,
  eccetera.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Nozioni preliminari}

Le nozioni qui riportate dovrebbero essere ben note, quindi le
passeremo in rassegna molto velocemente, solo per avere rifrimenti
facilmente accessibile nel seguito.

Teorema di divisione: quoziente e resto.

Numeri primi e numeri composti.  Numeri coprimi ovvero primi tra loro.

Teorema fondamentale dell'aritmetica e risulati correlati (se $p$ \`e
primo e $p \divides ab$ allora $p \divides a$ o $p \divides b$; se
$m \divides ab$ e $m$ ed $a$ sono coprimi, allora $m \divides b$; se
$a$ e $b$ sono coprimi ed entrambi dividono $c$, allora $ab \divides c$).

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\section{Massimo comun divisore e algoritmo di euclide}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Massimo comun divisore: definizione e propriet\`a di base}

Si dice \emph{massimo comun divisore} di due interi $a$ e $b$ (anche
negativi) il massimo intero positivo $d$ che divida sia $a$ che $b$.
In tal caso si scrive $d = \gcd{a}{b}$.  Se almeno uno tra $a$ o $b$
\`e diverso da zero, \`e chiaro che $d$ esiste (per esempio, assumendo
$a \neq 0$, ogni divisore comune di $a$ e $b$ dev'essere minore o
uguale ad $\abs{a}$).  D'altra parte, per evitare problemi, si pone
per definizione $\gcd{0}{0} := 0$.

Una prima ovvia propriet\`a \`e che $\gcd{a}{b} = \gcd{\abs{a}}{\abs{b}}$;
ci\`o permette spesso di fare calcoli e dimostrazioni riferendosi soltanto
ad interi positivi, ma ottenendo risultati che valgono anche per gli
interi negativi.

Enunciamo a questo punto un'importante propriet\`a del massimo comun
divisore: se $d = \gcd{a}{b}$, ed $m$ \`e un intero che divide sia $a$
che $b$, allora $m$ divide anche $d$\footnote{Questa \`e una conseguenza
del lemma di B\'ezout, che dimostreremo pi\`u avanti.}. D'altra parte, \`e
ovvio che se $m$ \`e un intero che divide $d$, allora esso divide sia $a$
che $b$. Quindi, in un certo senso, il massimo comun divisore ``contiene''
tutti gli altri divisori comuni.

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{L'algoritmo di euclide}

Dati due interi positivi\footnote{Quanto segue potrebbe essere facilmente
generalizzato anche ad interi negativi, ma noi ci limiteremo a trattare
interi positivi per non appesantire troppo la discussione} $a$ e $b$,
\`e possibile calcolare il loro massimo comun divisore con
l'\emph{algoritmo di Euclide}, che consiste in una serie di divisioni
\emph{intere} (cio\`e con quoziente e resto) successive:

\begin{displaymath}
  \begin{array}{rcll}
      r_0  & \!=\! & a \\
      r_1  & \!=\! & b \\
      r_0  & \!=\! & r_1 q_0 + r_2\,, & 0 < r_2 < r_1 \\
      r_1  & \!=\! & r_2 q_1 + r_3\,, & 0 < r_3 < r_2 \\
    \ldots &       & \ldots \\
   r_{n-1} & \!=\! & r_{n} q_{n-1} + r_{n+1}\,, & 0 < r_{n+1} < r_{n} \\
     r_{n} & \!=\! & r_{n+1} q_{n}\,, & r_{n+2} = 0 \\
  \end{array}
\end{displaymath}

Prima di tutto, siccome gli $r_i$ sono strettamente decrescenti al
crescere di $i$, prima o poi si raggiunger\`a un $i$ con $r_i = 0$,
quindi effettivamente l'algoritmo termina sempre.  Inoltre, \emph{l'ultimo
resto $\neq 0$} (cio\`e $r_{n+1}$) \emph{\`e il massimo comun divisore di
$a$ e $b$}, come ora dimostreremo.

\begin{proof}
Se $a = bq + r$, allora \`e facile vedere che ogni intero che divide
$a$ e $b$ divide anche $r$, e similmente che ogni intero che divide $b$
ed $r$ divide anche $a$.  Quindi l'insieme dei divisore comuni di $a$ e
$b$ concide con l'insieme de divisori comuni di $b$ ed $r$, e perci\`o
$\gcd{a}{b}$ (che \`e il massimo del primo insieme) \`e uguale a
$\gcd{b}{r}$ (che \`e il massimo del secondo insieme).

\smallskip
\noindent
Dunque, riprendendo la catena di divisioni dell'algoritmo, avremo:
\begin{eqnarray*}
  \gcd{a}{b}
    & =
    & \gcd{r_0}{r_1} = \gcd{r_1}{r_2} = \gcd{r_2}{r_3} = \ldots \\
  \ldots
    & =
    & \gcd{r_n}{r_{n+1}} = r_{n+1}
\end{eqnarray*}
dove l'ultima uguaglianza deriva dal fatto che $r_{n+1} \divides r_n$.
\end{proof}

\noindent
\TODO: Magari mostrare efficienza dell'algoritmo di euclide?

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Il Lemma di B\'ezout}

Se $d = \gcd{a}{b}$, allora esistono interi $x$ e $y$ (che possono 
anche essere negativi) tali che $ax + by = d$ (Lemma di B\'ezout).

La cosa importante \`e che $x$ e $y$ possono essere calcolati
efficientemente dall'algoritmo di euclide per $a$ e $b$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Aritmetica modulare}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Congruenze e operazioni modulo $m$}

\begin{definition}
Dato un intero positivo $m$ e due interi qualunque $a$ e $b$, si dice che
\emph{$a$ \`e congruente a $b$ modulo $m$}, e si scrive $a \congruent b
\mmod m$, se $m \divides \p{a - b}$, ossia se $a = b + tm$ per qualche
intero $t$.
\end{definition}

La relazione di congruenza modulo $m$ \`e una \emph{relazione di
equivalenza}, ossia:
\begin{enumerate}
\item $a \congruent a \mmod m$
\item $a \congruent b \mmod m \implies b \congruent a \mmod m$
\item $a \congruent b \mmod m ~\:\textrm{e}\:~
       b \congruent c \mmod m \implies
       a \congruent c \mmod m$
\end{enumerate}
La dimostrazione di queste tre propriet\`a \`e pressoch\`e immediata.

\smallskip
Ugualmente importante \`e il fatto che la relazione di congruenza
modulo $m$ \`e compatibile con le operazioni elementari:
%
\begin{theorem}
Se $a \congruent b \mmod m$ e\, $c \congruent d \mmod m$, allora
$a + c \congruent b + d \mmod m$, $a - c \congruent b - d \mmod m$,
e\, $ac \congruent bd \mmod m$.
\end{theorem}
%
\begin{proof}
Vediamo solo il caso della moltiplicazione (gli altri sono analoghi
e pi\`u semplici).  Siccome $a \congruent b \mmod m$, risulta
$m \divides \p{a - b}$, quindi a fortiori $m \divides \p{a - b}c =
ac - bc$, ossia $ac \congruent bc \mmod m$.  Similmente si prova
che, essendo $c \congruent d \mmod m$, risulta $bc \congruent bd
\mmod m$.  Allora, per transitivit\`a, $ac \congruent bd \mmod m$.
\end{proof}

Per la divisione abbiamo un risultato pi\`u debole, ma ugualmente
importante:
%
\begin{theorem}
Se $c$ ed $m$ sono coprimi, allora $ac \congruent bc \mmod m$ implica
che $a \congruent b \mmod m$.
\end{theorem}
%
\vspace*{-5pt}
\noindent
La dimostrazione segue facilmente dal teorema \XXX.

\begin{definition}
Un insieme di $m$ interi si dice \emph{sistema completo di residui modulo
$m$} se non ve ne sono due che siano congruenti tra loro modulo $m$.
\end{definition}

Il pi\`u semplice sistema completo di residui modulo $m$ \`e semplicemente
l'insieme $\set{0,\: 1,\: \ldots\: m - 1}$.

\smallskip
Vale il seguente risultato (che ci torner\`a utile pi\`u avanti):
%
\begin{theorem}
Se $A$ \`e un sistema completo di residui modulo $m$, allora per ogni
$i$ con $0 \leq i < m$ esiste uno ed uno solo $a_i \in A$ tale che
$a_i \congruent i \mmod m$.
\end{theorem}
%
\begin{proof}
Siano $a_0,\: \ldots\: a_{m-1}$ gli elementi di $A$, e siano $r_0,\:
\ldots\: r_{m-1}$ i rispettivi resti della divisione intera di quegli
elementi per $m$ (cosicch\`e $a_i \congruent r_i \mmod m$ per tutti
gli $i$).  Gli $r_i$ sono tutti distinti (se $r_h = r_k$ allora
$a_h \congruent a_k \mmod m$, e quindi $k = h$), e tutti compresi tra
$0$ ed $m - 1$ (essendo resti di una divisione per $m$); quindi, a
meno di un riodinamento, essi coincidono con gli interi $0,\: \ldots\:
m -1$.  Ma allora per ogni $i$ esiste un $r_i$ con $i = r_i$, e quindi
un $a_i \in A$ con $i \congruent r_i \congruent a_i \mmod m$.
L'unicit\`a di $a_i$ \`e poi ovvia.
\end{proof}

Il precedente teorema pu\`o essere usato facilmente per ottenere la
seguente generalizzazione:
%
\begin{corollary}
Se $A$ e $B$ sono due sistemi completi di residui modulo $m$, allora per
ogni $a \in A$ esiste uno ed uno solo $b \in B$ tale che $a \congruent b
\mmod m$.
\end{corollary}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Esponenziazione modulo $m$}

Algoritmo ottimizzato (``square-and-multiply''), che abbiamo usato nella
nostra implementazion python.

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Inverso modulo $m$}

\begin{definition}
L'inverso di un intero $a$ secondo il modulo $m$, \`e quell'intero $b$
tale che $ab \congruent 1 \mmod m$.  Non \`e detto che l'inverso di $a$
esista, ma se esiste \`e unico modulo $m$ (ossia due qualunque inversi
di $a$ sono congruenti tra loro modulo $m$).
\end{definition}

\begin{theorem}
Un intero $a$ (positivo o negativo) ha un inverso modulo $m$ se e solo se
$\gcd{a}{m} = 1$.
\end{theorem}

\begin{proof}[Prima dimostrazione]
Usare sistema completo di residui modulo $m$.
\end{proof}

\begin{proof}[Seconda dimostrazione]
Usare lemma di Bezout.
\end{proof}

La seconda dimostrazione ha il vantaggio di fornire un algoritmo pratico
ed efficiente per il calcolo degli inversi modulo $m$.

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Il ``piccolo'' teorema di Fermat}

``Piccolo'' teorema di Fermat (due dimostrazioni; la seconda non dipende
dall'esistenza dell'inverso modulo $m$, e pu\`o offire una dimostrazione
alternativa).

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Funzione $\phi$ e teoremi di Eulero}

\TODO: Funzione $\phi$ di Eulero: defn and properties.

La funzione di Eulero permette di ottenerare una nota generalizzazione
del teorema di Fermat\footnote{La cui dimostrazione ricalca la nostra
seconda dimostrazione del teorema di Fermat.}:

\begin{theorem}[Teorema di Eulero]\label{thm:euler}
  Sia $m$ un intero positvo. Allora, per ogni $a \in \Z$ con
  $\gcd{a}{m} = 1$, risulta\, $a^{\phi(m)} \congruent 1 \mmod m$.
\end{theorem}

\noindent
Ma a noi interessa una diversa (e meno nota) generalizzazione:

\begin{theorem}[Teorema di Eulero per RSA]\label{thm:euler-rsa}
Se $m$ \`e prodotto di due primi \emph{distinti}, allora risulta
$a^{\phi(m)} \congruent a \mmod m$ per \emph{ogni} intero $a$ (anche
non coprimo con $m$).
\end{theorem}
%
\begin{proof}
Sia $a$ un intero qualunque.  Allora, se $p \notdivides a$, dal teorema
di Fermat deriva che $a^{p-1} \congruent 1 \mmod p$, e quindi
$a^{\phi(m)} = a^{(p-1)(q-1)} = {\p{a^{p-1}}}^{q-1} \congruent 1^{q-1}
\congruent 1 \mmod p$.  D'altra parte, se $p \divides a$, allora
$a^{\phi(m)} \congruent 0^{\phi(m)} = 0 \congruent a \mmod p$.  In ogni
caso, $a^{\phi(m)} \congruent a \mmod p$.  Similamente, $a^{\phi(m)}
\congruent a \mmod q$, e quindi, essendo $p$ e $q$ coprimi (in quanto
primi distinti), $a^{\phi(m)} \congruent a \mmod{pq}$, ossia $\mmod m$.
\end{proof}

In effetti, il teorema qui sopra \`e valido per ogni intero $m$
\emph{libero da quadrati}, e la dimostrazione di ci\`o \`e una
semplice generalizzazione di quella appena data.  Ma per i nostri
scopi il caso $m = pq$ \`e sufficiente, quindi non ci soffermeremo
oltre.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Il crittosistema RSA}

\subsection{Basi teoriche}

\XXX[TODO ALL]

\subsection{Un esempio basilare dell'uso di RSA}

\TODO: see \verb+http://en.wikipedia.org/wiki/RSA#A_working_example+

\subsection{Schemi di padding a attachi ad RSA}

When used in practice, RSA is generally combined with some padding scheme.
The goal of the padding scheme is to prevent a number of attacks that
potentially work against RSA without padding:\\
\TODO: copia da wikipedia?

LINKS:\\
~~~\verb+http://en.wikipedia.org/wiki/RSA#Padding_schemes+\\
~~~\verb+http://en.wikipedia.org/wiki/Optimal_Asymmetric_Encryption_Padding+
~~~\verb+http://en.wikipedia.org/wiki/Random_oracle_model+

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{??? Firme digitali con RSA}

\XXX[TODO ALL]

\noindent Vedi anche:
\verb+http://en.wikipedia.org/wiki/Cryptographic_hash_function+

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{??? La nostra implementazione del crittosistema RSA in python}

\XXX[TODO ALL]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

% vim: ft=tex et ts=2 sw=2
