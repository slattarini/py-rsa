% -*- LaTeX -*-

\newif\ifoneside
\onesidetrue

\newif\ifuselinks
\uselinkstrue

\IfFileExists{RSA-ifuselinks.tex}{\input{RSA-ifuselinks.tex}}{}

\ifoneside
  \documentclass[pdflatex,11pt,a4paper,oneside]{article}
\else
  \documentclass[pdflatex,11pt,a4paper]{article}
\fi

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\usepackage[italian]{babel}
\usepackage{fancyhdr}
\usepackage{verbatim}
\usepackage{amsfonts,mathrsfs,amsmath,amssymb,amstext,amsthm}
\usepackage{xcolor}

\usepackage[perpage,symbol]{footmisc}

% hyperref should be the last package to be loaded.
\ifuselinks\usepackage{hyperref}\fi

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\newcommand{\theauthor}[0]{Stefano Lattarini}
\newcommand{\thetitle}[0]{Cenni teorici sul crittosistema RSA}

\renewcommand{\phi}{\varphi}

\newcommand{\XXX}[1][XXX]{\text{\bfseries{\color{red}{\emph{#1}}}}}
\newcommand{\TODO}[0]{\XXX[TODO]}
\newcommand{\FIXME}[0]{\XXX[FIXME]}
\newcommand{\UNEXPANDED}[0]{\XXX[SHOULD-BE-UNEXPANDED]}

\newcommand{\acro}[1]{\text{{\frenchspacing {#1} }}}
\newcommand{\ie}[0]{\acro{i.e.}}
\newcommand{\eg}[0]{\acro{e.g.}}
\newcommand{\tc}[0]{\acro{t.c.}}

\newcommand{\p}[1]{\left({#1}\right)}
\newcommand{\q}[1]{\left({#1}\right)^2}
\newcommand{\abs}[1]{\left|{#1}\right|}
\newcommand{\card}[1]{\abs{#1}}
\newcommand{\varcard}[2][\,]{\pmb{\#}{#1}{#2}}

\newcommand{\N}[0]{\mathbb{N}}
\newcommand{\Z}[0]{\mathbb{Z}}

\newcommand{\divides}[0]{\mid}
\newcommand{\notdivides}[0]{\nmid}

\newcommand{\congruent}[0]{\equiv}
\newcommand{\notcongruent}[0]{\not\equiv}
\newcommand{\mmodop}[0]{\ensuremath{\operatorname{mod}}}
\newcommand{\mmod}[1]{\ensuremath{\allowbreak\ (\mmodop\:{#1})}}
\newcommand{\xmod}[1]{\ensuremath{\allowbreak\ \left(\mmodop\:{#1}\right)}}

\newcommand{\cc}[2][m]{\ensuremath{\left[\:{#2}\,\right]_{\,#1}}}

\newcommand{\iseq}[1]{\ensuremath{0,\,1,\,\ldots,\, {#1} - 1}}
\newcommand{\set}[1]{\ensuremath{\left\{\,{#1}\,\right\}}}
\newcommand{\setdef}[2]{\set{{#1}:\:{#2}}}

\newcommand{\gcdop}[0]{\ensuremath{\mathtt{g.c.d.}}}
\newcommand{\xgcd}[1]{\ensuremath{\gcdop\left({#1}\right)}}
\renewcommand{\gcd}[2]{\xgcd{{#1},\,{#2}}}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\newtheorem{TheoremLike}{\UNEXPANDED}
\newtheorem{algorithm}[TheoremLike]{Algoritmo}
\newtheorem{*xalgorithm}{Algoritmo}
\newtheorem{theorem}[TheoremLike]{Teorema}
\newtheorem*{xtheorem}{Teorema}
\newtheorem{definition}[TheoremLike]{Definizione}
\newtheorem*{xdefinition}{Definizione}
\newtheorem{lemma}[TheoremLike]{Lemma}
\newtheorem*{xlemma}{Lemma}
\newtheorem{corollary}[TheoremLike]{Corollario}
\newtheorem*{xcorollary}{Corollario}
\newtheorem{proposition}[TheoremLike]{Proposizione}
\newtheorem*{xproposition}{Proposizione}
\newtheorem{example}[TheoremLike]{Esempio}
\newtheorem*{xexample}{Esempio}
\newtheorem{property}[TheoremLike]{Propriet\`a}
\newtheorem*{xproperty}{Propriet\`a}
\newtheorem{remark}[TheoremLike]{Osservazione}
\newtheorem*{xremark}{Osservazione}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markright{\thesection~\:#1}}
\fancyhf{} % clear all header fields
\fancyhead[RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\ifoneside
  \relax
\else
  \fancyhead[RE]{\bfseries\leftmark}
  \fancyhead[LE]{\bfseries\thepage}
\fi
\fancyfoot{} % clear all footer fields
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{0.5pt}
\fancypagestyle{plain}{
  \fancyhf{} % clear all header and footer fields
  \fancyfoot[C]{\bfseries \thepage} % except the center
  \renewcommand{\headrulewidth}{0pt}
  \renewcommand{\footrulewidth}{0pt}
}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\DefineFNsymbols*{myftnsymbol}{%
  \dagger%
  \ddagger%
  \S%
  \sharp%
  \clubsuit%
  \spadesuit%
  \P%
}

\setfnsymbol{myftnsymbol}

\ifuselinks
  \hypersetup{
    backref,
    pdftitle={\thetitle},
    pdfauthor={\theauthor}
    pdfborder={0 0 0},
    anchorcolor=green,
    colorlinks,
    linkcolor=blue,
    pdfpagelabels
  }
\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title{\thetitle}
\author{\theauthor}
%\date{YEAR-MONTH-DAY}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
  Cenni di teoria circa la nostra implementazione didattica del
  crittosistema RSA.  Si assume una conoscenza di base dell'aritmetica
  teorica -- e.g., principio di induzione e del minimo intero, definizione
  e semplici propriet\`a dei numeri primi e composti, teorema fondamentale
  dell'aritmetica, divisione con resto, eccetera.  Alcuni di questi
  concetti saranno comunque brevementi richiamati.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Nozioni preliminari}

Le nozioni qui riportate dovrebbero essere ben note, quindi le
passeremo in rassegna molto velocemente, solo per avere riferimenti
facilmente accessibile nel seguito.

\begin{theorem}[Teorema di divisione]
Dati due interi (non necessariamente positivi) $a$ e $b$ con $b \neq 0$,
esistono due interi $q$ ed $r$ tali che $a = bq + r$ e $0 \leq r
< \abs{b}$. Essi sono unici, e sono chiamati rispettivamente
\emph{quoziente} e \emph{resto} della divisione di $a$ per $b$.
\end{theorem}

\begin{definition}[Numeri primi e composti]
Un intero $p > 1$ che sia divisibile soltanto per s\`e stesso e per
l'unit\`a \`e detto \emph{numero primo}.  Un intero $m > 1$ che non
sia primo \`e detto \emph{composto}; in tal caso esistono due interi
$m_1$, $m_2$ con $1 < m_i < m$ tali che $m = m_1 m_2$.
\end{definition}

\begin{definition}[Interi coprimi]
Due interi si dicono \emph{coprimi} (ovvero \emph{primi tra loro}) se
non hanno divisori comuni al di fuori dell'unit\`a.
\end{definition}

\begin{theorem}[Teorema fondamentale dell'aritmetica]
Ogni intero positivo possiede una fattorizzazione in numeri primi, e
tale fattorizzazione \`e unica (a meno di un riordinamento dei fattori).
\end{theorem}

Valgono inoltre i seguenti risulati, che sono conseguenze pressoch\`e
immediate del teorema fondamentale dell'aritmentica\footnote{In effetti,
si pu\`o facilmente vedere che essi sono \emph{equivalenti} a tale
teorema.}:

\begin{theorem}\label{thm:TFA-c1}
Se $p$ \`e primo e \,$p \divides ab$, allora \,$p \divides a$\, o
\,$p \divides b$.
\end{theorem}

\begin{theorem}\label{thm:TFA-c2}
Se $m \divides ab$, ed\, $m$ ed\, $a$ sono coprimi, allora $m \divides b$.
\end{theorem}

\begin{theorem}\label{thm:TFA-c3}
Se $a$, $b$ sono coprimi ed entrambi dividono $c$, allora
anche $ab$ divide $c$.
\end{theorem}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\section{Massimo comun divisore e algoritmo di Euclide}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Massimo comun divisore: definizione e propriet\`a di base}

Si dice \emph{massimo comun divisore} di due interi $a$ e $b$ (anche
negativi) il massimo intero positivo $d$ che divida sia $a$ che $b$.
In tal caso si scrive $d = \gcd{a}{b}$.  Se almeno uno tra $a$ o $b$
\`e diverso da zero, \`e chiaro che $d$ esiste (per esempio, assumendo
$a \neq 0$, ogni divisore comune di $a$ e $b$ dev'essere minore o
uguale ad $\abs{a}$).  D'altra parte, per evitare problemi, si pone
per definizione $\gcd{0}{0} := 0$.

Una prima ovvia propriet\`a \`e che $\gcd{a}{b} = \gcd{\abs{a}}{\abs{b}}$;
ci\`o permette spesso di fare calcoli e dimostrazioni riferendosi soltanto
ad interi positivi, ma ottenendo risultati che valgono anche per gli
interi negativi.

Un'importantissima propriet\`a del massimo comun divisore \`e che, se
$m$ \`e un intero che divide sia $a$ che $b$, allora $m$ divide anche
$\gcd{a}{b}$\footnote{Questa \`e una conseguenza del lemma di B\'ezout,
che dimostreremo pi\`u avanti.}. D'altra parte, \`e ovvio che se $m$ \`e 
un intero che divide $d = \gcd{a}{b}$, allora esso divide sia $a$ che $b$
(poich\`e $d$ \`e un divisore comune ad essi).  Quindi, in un certo senso,
il massimo comun divisore ``contiene'' tutti gli altri divisori comuni.

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{L'algoritmo di Euclide}

Dati due interi positivi\footnote{Quanto segue potrebbe essere facilmente
generalizzato anche ad interi negativi, ma noi ci limiteremo a trattare
interi positivi per non appesantire troppo la discussione} $a$ e $b$,
\`e possibile calcolare il loro massimo comun divisore con
l'\emph{algoritmo di Euclide}, che consiste in una serie di divisioni
\emph{intere} (cio\`e con quoziente e resto) successive:

\begin{displaymath}
  \begin{array}{rcll}
      r_0  & \!=\! & a \\
      r_1  & \!=\! & b \\
      r_0  & \!=\! & r_1 q_0 + r_2\,, & 0 < r_2 < r_1 \\
      r_1  & \!=\! & r_2 q_1 + r_3\,, & 0 < r_3 < r_2 \\
    \ldots &       & \ldots \\
   r_{n-1} & \!=\! & r_{n} q_{n-1} + r_{n+1}\,, & 0 < r_{n+1} < r_{n} \\
     r_{n} & \!=\! & r_{n+1} q_{n}\,, & r_{n+2} = 0 \\
  \end{array}
\end{displaymath}

Prima di tutto, siccome gli $r_i$ sono strettamente decrescenti al
crescere di $i$, prima o poi si raggiunger\`a un $i$ con $r_i = 0$,
quindi effettivamente l'algoritmo termina sempre.  Inoltre, \emph{l'ultimo
resto $\neq 0$} (cio\`e $r_{n+1}$) \emph{\`e il massimo comun divisore di
$a$ e $b$}, come ora dimostreremo.

\begin{proof}
Se $a = bq + r$, allora \`e facile vedere che ogni intero che divide
$a$ e $b$ divide anche $r$, e similmente che ogni intero che divide $b$
ed $r$ divide anche $a$.  Quindi l'insieme dei divisore comuni di $a$ e
$b$ concide con l'insieme de divisori comuni di $b$ ed $r$, e perci\`o
$\gcd{a}{b}$ (che \`e il massimo del primo insieme) \`e uguale a
$\gcd{b}{r}$ (che \`e il massimo del secondo insieme).

\smallskip
\noindent
Dunque, riprendendo la catena di divisioni dell'algoritmo, avremo:
\begin{eqnarray*}
  \gcd{a}{b}
    & =
    & \gcd{r_0}{r_1} = \gcd{r_1}{r_2} = \gcd{r_2}{r_3} = \ldots \\
  \ldots
    & =
    & \gcd{r_n}{r_{n+1}} = r_{n+1}
\end{eqnarray*}
dove l'ultima uguaglianza deriva dal fatto che $r_{n+1} \divides r_n$.
\end{proof}

\noindent
\TODO: Magari mostrare efficienza dell'algoritmo di Euclide?

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Il Lemma di B\'ezout}

\begin{theorem}[Lemma di B\'ezout]\label{thm:lemma-bezout}
Se $d = \gcd{a}{b}$, allora esistono interi $x$ e $y$ (che possono
anche essere negativi) tali che $ax + by = d$.
\end{theorem}
%
\begin{proof}
Dimostriamo per induzione su $m$ che ogni resto $r_m$ nell'algoritmo
di Euclide \`e rappresentabile come $ax_m + by_m$ per opportuni interi
$x_m$, $y_m$. Ci\`o \`e evidente nei casi $m = 0$ ($r_0 = a = a \cdot 1 +
b \cdot 0$) e $m = 1$ ($r_1 = b = a \cdot 0 + b \cdot 1$). Assumendo poi
che la tesi sia vera per $m - 2$ ed $m - 1$, abbiamo:
\begin{eqnarray*}
r_m & = & r_{m-2} - r_{m-1} q_{m-2} = ax_{m-2} + by_{m-2} -
                                      \p{ax_{m-1} + by_{m-1}} q_{m-2} \\
& = &
a\p{x_{m-2} - q_{m-2}x_{m-1}} + b\p{y_{m-2} - q_{m-2}y_{m-1}}
\end{eqnarray*}
coiscch\`e la tesi \`e vera anche per $m$.  Poich\`e $\gcd{a}{b} =
r_{n+1}$, abbiamo finito.
\end{proof}

Si noti che la dimostrazione precedente offre in effetti un algoritmo
pratico (iterativo) per il calcolo di  $x$ ed $y$ (algoritmo che \`e in
effetti un'estensione dell'algoritmo di Euclide applicato ad $a$ e $b$,
ed \`e perci\`o noto col nome di \emph{algoritmo di Euclide esteso}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Aritmetica modulare}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Congruenze e operazioni modulo $m$}

\begin{definition}
Dato un intero positivo $m$ e due interi qualunque $a$ e $b$, si dice che
\emph{$a$ \`e congruente a $b$ modulo $m$}, e si scrive $a \congruent b
\mmod m$, se $m \divides \p{a - b}$, ossia se $a = b + tm$ per qualche
intero $t$.
\end{definition}

La relazione di congruenza modulo $m$ \`e una \emph{relazione di
equivalenza}, ossia:
\begin{enumerate}
\item $a \congruent a \mmod m$
\item $a \congruent b \mmod m \implies b \congruent a \mmod m$
\item $a \congruent b \mmod m ~\:\textrm{e}\:~
       b \congruent c \mmod m \implies
       a \congruent c \mmod m$
\end{enumerate}
La dimostrazione di queste tre propriet\`a \`e pressoch\`e immediata.

\smallskip
Ugualmente importante \`e il fatto che la relazione di congruenza
modulo $m$ \`e compatibile con le operazioni elementari:
%
\begin{theorem}
Se $a \congruent b \mmod m$ e\, $c \congruent d \mmod m$, allora
$a + c \congruent b + d \mmod m$, $a - c \congruent b - d \mmod m$,
e\, $ac \congruent bd \mmod m$.
\end{theorem}
%
\begin{proof}
Vediamo solo il caso della moltiplicazione (gli altri sono analoghi
e pi\`u semplici).  Siccome $a \congruent b \mmod m$, risulta
$m \divides \p{a - b}$, quindi a fortiori $m \divides \p{a - b}c =
ac - bc$, ossia $ac \congruent bc \mmod m$.  Similmente si prova
che, essendo $c \congruent d \mmod m$, risulta $bc \congruent bd
\mmod m$.  Allora, per transitivit\`a, $ac \congruent bd \mmod m$.
\end{proof}

Per la divisione abbiamo un risultato pi\`u debole, ma ugualmente
importante:
%
\begin{theorem}\label{thm:simplify-modulo-m}
Se $c$ ed $m$ sono coprimi, allora $ac \congruent bc \mmod m$ implica
che $a \congruent b \mmod m$.
\end{theorem}
%
\begin{proof}
Abbiamo che $ac \congruent bc \mmod m$, ossia $m \divides \p{a -b}c$.
Poich\`e $c$ ed $m$ sono coprimi, dal teorema~\eqref{thm:TFA-c2}
segue che $m \divides \p{a -b}c$, \ie $a \congruent b \mmod m$.
\end{proof}

\begin{definition}
Un insieme di $m$ interi si dice \emph{sistema completo di residui modulo
$m$} se non ve ne sono due che siano congruenti tra loro modulo $m$.
\end{definition}

Il pi\`u semplice sistema completo di residui modulo $m$ \`e semplicemente
l'insieme $\set{0,\: 1,\: \ldots\: m - 1}$.

\smallskip
Vale il seguente risultato (che ci torner\`a utile pi\`u avanti):
%
\begin{theorem}\label{thm:complete-residue-system}
Se $A$ \`e un sistema completo di residui modulo $m$, allora per ogni
$i$ con $0 \leq i < m$ esiste uno ed uno solo $a_i \in A$ tale che
$a_i \congruent i \mmod m$.
\end{theorem}
%
\begin{proof}
Siano $a_0,\: \ldots\: a_{m-1}$ gli elementi di $A$, e siano $r_0,\:
\ldots\: r_{m-1}$ i rispettivi resti della divisione intera di quegli
elementi per $m$ (cosicch\`e $a_i \congruent r_i \mmod m$ per tutti
gli $i$).  Gli $r_i$ sono tutti distinti (se $r_h = r_k$ allora
$a_h \congruent a_k \mmod m$, e quindi $k = h$), e tutti compresi tra
$0$ ed $m - 1$ (essendo resti di una divisione per $m$); quindi, a
meno di un riodinamento, essi coincidono con gli interi $0,\: \ldots\:
m -1$.  Ma allora per ogni $i$ esiste un $r_i$ con $i = r_i$, e quindi
un $a_i \in A$ con $i \congruent r_i \congruent a_i \mmod m$.
L'unicit\`a di $a_i$ \`e poi ovvia.
\end{proof}

Il precedente teorema pu\`o essere usato facilmente per ottenere la
seguente generalizzazione:
%
\begin{corollary}
Se $A$ e $B$ sono due sistemi completi di residui modulo $m$, allora per
ogni $a \in A$ esiste uno ed uno solo $b \in B$ tale che $a \congruent b
\mmod m$.
\end{corollary}

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Esponenziazione modulo $m$}

Algoritmo ottimizzato (``square-and-multiply''), che abbiamo usato nella
nostra implementazion python.

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Inverso modulo $m$}

\begin{definition}
Dato un intero $a$, il suo inverso secondo il modulo $m$, \`e quell'intero
$b$ (se esiste) tale che $ab \congruent 1 \mmod m$.
\end{definition}

Non \`e detto che l'inverso di $a$ esista, ma se esiste \`e unico modulo $m$
(ossia due qualunque inversi di $a$ sono congruenti tra loro modulo $m$).
Precisamente, abbiamo il seguente risultato:

\begin{theorem}
Un intero $a$ (positivo o negativo) ha un inverso modulo $m$ se e solo se
$\gcd{a}{m} = 1$.  In tal caso, tale inverso \`e unico modulo $m$.
\end{theorem}

\`E chiaro che $a$ dev'esse coprimo con $m$ per avere un inverso, poich\`e
l'avere $ab \congruent 1 \mmod m$ implica che ogni divisore comune di $a$
ed $m$ divide anche $1$, e pu\`o quindi essere solo l'unit\`a stessa.

\medskip\noindent
Vediamo ora di dimostrare le altre parti del teorema.

\begin{proof}[Dimostrazione di unicit\`a]
Siano $x, y$ tali che $ax \congruent 1 \mmod m$ e $ay \congruent 1
\mmod m$; allora $ax \congruent ay \mmod m$, e quindi per il
teorema~\eqref{thm:simplify-modulo-m} abbiamo che $x \congruent y
\mmod m$.
\end{proof}

\begin{proof}[Prima dimostrazione di esistenza]
Sia $a$ un intero coprimo con $m$, e sia $X := \setdef{ab}{b = 0,\: 1,\:
\ldots\: m - 1}$. $X$ \`e chiaramente un sistema completo di residui modulo
$m$, in quanto contiene $m$ elementi, e nessuno di essi \`e congruente ad
un altro modulo $m$ (in virt\`u del teorema~\eqref{thm:simplify-modulo-m}).
Dal teorema~\eqref{thm:complete-residue-system} segue quindi che esiste un
$x \in X$ con $x \congruent 1 \mmod m$; poich\`e $x = ab$, $b$ \`e inverso
di $a$ modulo $m$.
\end{proof}

\begin{proof}[Seconda dimostrazione di esistenza]
Sia $a$ un intero coprimo con $m$.  Allora $\gcd{a}{m} = 1$, quindi per il
lemma di B\'ezout esistono due interi $x$ ed $y$ tali che $ax + my = 1$,
da cui $ax \congruent 1 \mmod m$.
\end{proof}

La seconda dimostrazione di esistenza ha il vantaggio di fornire un
algoritmo pratico ed efficiente per il calcolo degli inversi modulo $m$
(poich\`e $x$ pu\`o essere calcolato con l'algoritmo di Euclide esteso).

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Il ``piccolo'' teorema di Fermat}

``Piccolo'' teorema di Fermat (due dimostrazioni; la seconda non dipende
dall'esistenza dell'inverso modulo $m$, e pu\`o offire una dimostrazione
alternativa).

%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Funzione $\phi$ e teoremi di Eulero}

\TODO: Funzione $\phi$ di Eulero: defn and properties.

La funzione di Eulero permette di ottenerare una nota generalizzazione
del teorema di Fermat\footnote{La cui dimostrazione ricalca la nostra
seconda dimostrazione del teorema di Fermat.}:

\begin{theorem}[Teorema di Eulero]\label{thm:euler}
  Sia $m$ un intero positvo. Allora, per ogni $a \in \Z$ con
  $\gcd{a}{m} = 1$, risulta\, $a^{\phi(m)} \congruent 1 \mmod m$.
\end{theorem}

\noindent
Ma a noi interessa una diversa (e meno nota) generalizzazione:

\begin{theorem}[Teorema di Eulero per RSA]\label{thm:euler-rsa}
Se $m$ \`e prodotto di due primi \emph{distinti}, allora risulta
$a^{\phi(m)} \congruent a \mmod m$ per \emph{ogni} intero $a$ (anche
non coprimo con $m$).
\end{theorem}
%
\begin{proof}
Sia $a$ un intero qualunque.  Allora, se $p \notdivides a$, dal teorema
di Fermat deriva che $a^{p-1} \congruent 1 \mmod p$, e quindi
$a^{\phi(m)} = a^{(p-1)(q-1)} = {\p{a^{p-1}}}^{q-1} \congruent 1^{q-1}
\congruent 1 \mmod p$.  D'altra parte, se $p \divides a$, allora
$a^{\phi(m)} \congruent 0^{\phi(m)} = 0 \congruent a \mmod p$.  In ogni
caso, $a^{\phi(m)} \congruent a \mmod p$.  Similamente, $a^{\phi(m)}
\congruent a \mmod q$, e quindi, essendo $p$ e $q$ coprimi (in quanto
primi distinti), $a^{\phi(m)} \congruent a \mmod{pq}$, ossia $\mmod m$.
\end{proof}

In effetti, il teorema qui sopra \`e valido per ogni intero $m$
\emph{libero da quadrati}, e la dimostrazione di ci\`o \`e una
semplice generalizzazione di quella appena data.  Ma per i nostri
scopi il caso $m = pq$ \`e sufficiente, quindi non ci soffermeremo
oltre.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Il crittosistema RSA}

\subsection{Basi teoriche}

\XXX[TODO ALL]

\subsection{Un esempio basilare dell'uso di RSA}

\TODO: see \verb+http://en.wikipedia.org/wiki/RSA#A_working_example+

\subsection{Schemi di padding a attachi ad RSA}

When used in practice, RSA is generally combined with some padding scheme.
The goal of the padding scheme is to prevent a number of attacks that
potentially work against RSA without padding:\\
\TODO: copia da wikipedia?

LINKS:\\
~~~\verb+http://en.wikipedia.org/wiki/RSA#Padding_schemes+\\
~~~\verb+http://en.wikipedia.org/wiki/Optimal_Asymmetric_Encryption_Padding+
~~~\verb+http://en.wikipedia.org/wiki/Random_oracle_model+

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{??? Firme digitali con RSA}

\XXX[TODO ALL]

\noindent Vedi anche:
\verb+http://en.wikipedia.org/wiki/Cryptographic_hash_function+

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{??? La nostra implementazione del crittosistema RSA in python}

\XXX[TODO ALL]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

% vim: ft=tex et ts=2 sw=2
